// app/api/invoices/[id]/route.ts
// GET   /api/invoices/:id   — invoice detail with line items
// PATCH /api/invoices/:id   — update status: send, pay, void

import { NextRequest, NextResponse } from "next/server";
import { getSql } from "@/db/connection";
import { requireAuth } from "@/lib/apiAuth";

export const runtime = "nodejs";
export const dynamic = "force-dynamic";

export async function GET(
	request: NextRequest,
	{ params }: { params: { id: string } }
) {
	const auth = await requireAuth(request);
	if (!auth.ok) return auth.response;
	const { companyId } = auth.user;
	const sql = getSql();

	const [invoice] = (await sql`
		SELECT
			i.id,
			i.invoice_number  AS "invoiceNumber",
			i.customer_id     AS "customerId",
			i.agreement_id    AS "agreementId",
			i.job_id          AS "jobId",
			i.estimate_id     AS "estimateId",
			i.status,
			i.subtotal,
			i.tax_rate        AS "taxRate",
			i.tax_amount      AS "taxAmount",
			i.total,
			i.amount_paid     AS "amountPaid",
			i.balance_due     AS "balanceDue",
			i.due_date        AS "dueDate",
			i.paid_at         AS "paidAt",
			i.sent_at         AS "sentAt",
			i.auto_generated  AS "autoGenerated",
			i.notes,
			i.created_at      AS "createdAt",
			i.updated_at      AS "updatedAt",
			c.first_name || ' ' || c.last_name AS "customerName",
			c.email           AS "customerEmail",
			c.phone           AS "customerPhone",
			c.address         AS "customerAddress",
			c.city, c.state, c.zip
		FROM invoices i
		JOIN customers c ON c.id = i.customer_id
		WHERE i.id = ${params.id} AND i.company_id = ${companyId}
	`) as any[];

	if (!invoice) {
		return NextResponse.json({ error: "Invoice not found" }, { status: 404 });
	}

	const lineItems = await sql`
		SELECT
			id,
			pricebook_item_id AS "pricebookItemId",
			item_type         AS "itemType",
			name, description, quantity,
			unit_price        AS "unitPrice",
			unit_cost         AS "unitCost",
			taxable,
			sort_order        AS "sortOrder"
		FROM invoice_line_items
		WHERE invoice_id = ${params.id}
		ORDER BY sort_order, created_at
	`;

	return NextResponse.json({ invoice: { ...invoice, lineItems } });
}

export async function PATCH(
	request: NextRequest,
	{ params }: { params: { id: string } }
) {
	const auth = await requireAuth(request);
	if (!auth.ok) return auth.response;
	const { companyId } = auth.user;

	let body: any;
	try { body = await request.json(); } catch {
		return NextResponse.json({ error: "Invalid JSON" }, { status: 400 });
	}

	const sql = getSql();

	const [existing] = (await sql`
		SELECT id, status, total FROM invoices
		WHERE id = ${params.id} AND company_id = ${companyId}
	`) as any[];

	if (!existing) {
		return NextResponse.json({ error: "Invoice not found" }, { status: 404 });
	}

	const { action, amountPaid, stripePaymentIntentId, dueDate, notes } = body;

	if (action === "send") {
		if (existing.status !== "draft") {
			return NextResponse.json({ error: "Only draft invoices can be sent" }, { status: 400 });
		}
		const [updated] = (await sql`
			UPDATE invoices SET status = 'sent', sent_at = NOW(), updated_at = NOW()
			WHERE id = ${params.id}
			RETURNING id, status, sent_at AS "sentAt"
		`) as any[];
		return NextResponse.json({ invoice: updated });
	}

	if (action === "pay") {
		const payment = amountPaid ?? Number(existing.total);
		const [updated] = (await sql`
			UPDATE invoices SET
				amount_paid = ${payment},
				status = CASE WHEN ${payment} >= total THEN 'paid' ELSE 'partial' END,
				paid_at = CASE WHEN ${payment} >= total THEN NOW() ELSE paid_at END,
				stripe_payment_intent_id = COALESCE(${stripePaymentIntentId ?? null}, stripe_payment_intent_id),
				updated_at = NOW()
			WHERE id = ${params.id}
			RETURNING
				id, status,
				amount_paid     AS "amountPaid",
				balance_due     AS "balanceDue",
				paid_at         AS "paidAt",
				updated_at      AS "updatedAt"
		`) as any[];
		return NextResponse.json({ invoice: updated });
	}

	if (action === "void") {
		if (existing.status === "paid") {
			return NextResponse.json(
				{ error: "Cannot void a paid invoice — issue a refund instead" },
				{ status: 409 }
			);
		}
		const [updated] = (await sql`
			UPDATE invoices SET status = 'void', updated_at = NOW()
			WHERE id = ${params.id}
			RETURNING id, status, updated_at AS "updatedAt"
		`) as any[];
		return NextResponse.json({ invoice: updated });
	}

	// General field updates (due date, notes)
	const [updated] = (await sql`
		UPDATE invoices SET
			due_date   = COALESCE(${dueDate ?? null}, due_date),
			notes      = COALESCE(${notes ?? null}, notes),
			updated_at = NOW()
		WHERE id = ${params.id}
		RETURNING id, status, due_date AS "dueDate", notes, updated_at AS "updatedAt"
	`) as any[];

	return NextResponse.json({ invoice: updated });
}
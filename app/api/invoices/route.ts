// app/api/invoices/route.ts
// GET  /api/invoices   — list invoices (filter by customer, status, agreement)
// POST /api/invoices   — create invoice manually with line items

import { NextRequest, NextResponse } from "next/server";
import { getSql } from "@/db/connection";
import { requireAuth } from "@/lib/apiAuth";

export const runtime = "nodejs";
export const dynamic = "force-dynamic";

export async function GET(request: NextRequest) {
	const auth = await requireAuth(request);
	if (!auth.ok) return auth.response;
	const { companyId } = auth.user;
	const { searchParams } = new URL(request.url);
	const customerId = searchParams.get("customerId");
	const status = searchParams.get("status");
	const agreementId = searchParams.get("agreementId");

	const sql = getSql();
	const rows = await sql`
		SELECT
			i.id,
			i.invoice_number  AS "invoiceNumber",
			i.customer_id     AS "customerId",
			i.agreement_id    AS "agreementId",
			i.job_id          AS "jobId",
			i.estimate_id     AS "estimateId",
			i.status,
			i.subtotal,
			i.tax_rate        AS "taxRate",
			i.tax_amount      AS "taxAmount",
			i.total,
			i.amount_paid     AS "amountPaid",
			i.balance_due     AS "balanceDue",
			i.due_date        AS "dueDate",
			i.paid_at         AS "paidAt",
			i.sent_at         AS "sentAt",
			i.auto_generated  AS "autoGenerated",
			i.notes,
			i.created_at      AS "createdAt",
			c.first_name || ' ' || c.last_name AS "customerName"
		FROM invoices i
		JOIN customers c ON c.id = i.customer_id
		WHERE i.company_id = ${companyId}
			${customerId ? sql`AND i.customer_id = ${customerId}` : sql``}
			${status ? sql`AND i.status = ${status}` : sql``}
			${agreementId ? sql`AND i.agreement_id = ${agreementId}` : sql``}
		ORDER BY i.created_at DESC
		LIMIT 100
	`;

	return NextResponse.json({ invoices: rows });
}

export async function POST(request: NextRequest) {
	const auth = await requireAuth(request);
	if (!auth.ok) return auth.response;
	const { companyId } = auth.user;

	let body: any;
	try { body = await request.json(); } catch {
		return NextResponse.json({ error: "Invalid JSON" }, { status: 400 });
	}

	const {
		customerId, agreementId, jobId,
		lineItems = [], taxRate = 0,
		dueDate, notes
	} = body;

	if (!customerId || lineItems.length === 0) {
		return NextResponse.json(
			{ error: "customerId and lineItems are required" },
			{ status: 400 }
		);
	}

	const subtotal = lineItems.reduce(
		(sum: number, item: any) => sum + item.quantity * item.unitPrice, 0
	);
	const taxableAmount = lineItems
		.filter((li: any) => li.taxable !== false)
		.reduce((sum: number, li: any) => sum + li.quantity * li.unitPrice, 0);
	const taxAmount = Math.round(taxableAmount * taxRate * 100) / 100;
	const total = Math.round((subtotal + taxAmount) * 100) / 100;

	const invoiceNumber = `INV-${Date.now().toString(36).toUpperCase()}`;

	const sql = getSql();

	const [invoice] = (await sql`
		INSERT INTO invoices (
			company_id, customer_id, agreement_id, job_id,
			invoice_number, subtotal, tax_rate, tax_amount, total,
			due_date, notes, auto_generated
		) VALUES (
			${companyId}, ${customerId}, ${agreementId ?? null}, ${jobId ?? null},
			${invoiceNumber}, ${subtotal}, ${taxRate}, ${taxAmount}, ${total},
			${dueDate ?? null}, ${notes ?? null}, FALSE
		)
		RETURNING id, invoice_number AS "invoiceNumber", status, total, created_at AS "createdAt"
	`) as any[];

	// Insert line items
	for (let i = 0; i < lineItems.length; i++) {
		const li = lineItems[i];
		await sql`
			INSERT INTO invoice_line_items (
				invoice_id, item_type, name, description,
				quantity, unit_price, unit_cost, taxable, sort_order
			) VALUES (
				${invoice.id},
				${li.itemType ?? 'custom'},
				${li.name},
				${li.description ?? null},
				${li.quantity},
				${li.unitPrice},
				${li.unitCost ?? null},
				${li.taxable !== false},
				${i}
			)
		`;
	}

	return NextResponse.json({ invoice }, { status: 201 });
}